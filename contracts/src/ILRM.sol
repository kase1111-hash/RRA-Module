// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/utils/ReentrancyGuard.sol";
import "@openzeppelin/contracts/utils/Pausable.sol";

/**
 * @title IGroth16Verifier
 * @notice Interface for ZK proof verification (generated by snarkjs)
 */
interface IGroth16Verifier {
    function verifyProof(
        uint[2] calldata _pA,
        uint[2][2] calldata _pB,
        uint[2] calldata _pC,
        uint[1] calldata _pubSignals
    ) external view returns (bool);
}

/**
 * @title ILRM - Incentivized Layered Resolution Module
 * @notice Privacy-preserving dispute resolution with ZK identity proofs
 *
 * Features:
 * - ZK identity proofs for anonymous dispute participation
 * - Viewing key commitments for selective de-anonymization
 * - Multi-phase escalation (negotiation → mediation → arbitration)
 * - Staking-based incentive alignment
 *
 * Privacy Architecture:
 * 1. Parties identified by hashes (initiatorHash, counterpartyHash)
 * 2. ZK proofs verify party identity without revealing addresses
 * 3. Viewing keys enable authorized access to encrypted evidence
 * 4. All sensitive data stored off-chain (IPFS/Arweave)
 */
contract ILRM is Ownable, ReentrancyGuard, Pausable {
    // =========================================================================
    // Types
    // =========================================================================

    enum DisputePhase {
        Initiated,      // Dispute created, awaiting counterparty response
        Negotiation,    // Direct negotiation between parties
        Mediation,      // Third-party mediator involved
        Arbitration,    // Binding arbitration
        Resolved,       // Settlement reached
        Dismissed       // Dispute dismissed (timeout/invalid)
    }

    enum Resolution {
        None,
        InitiatorWins,
        CounterpartyWins,
        MutualSettlement,
        Dismissed
    }

    struct Dispute {
        uint256 id;
        bytes32 initiatorHash;        // Poseidon hash of initiator's identity secret
        bytes32 counterpartyHash;     // Poseidon hash of counterparty's identity secret
        bytes32 viewingKeyCommitment; // Commitment to viewing key for evidence decryption
        bytes32 evidenceHash;         // Hash of encrypted evidence (content on IPFS)
        uint256 stakeAmount;          // Amount staked by initiator
        uint256 counterpartyStake;    // Amount staked by counterparty
        uint256 createdAt;
        uint256 lastActionAt;
        uint256 deadline;             // Current phase deadline
        DisputePhase phase;
        Resolution resolution;
        bool initiatorVerified;       // Has initiator submitted valid ZK proof
        bool counterpartyVerified;    // Has counterparty submitted valid ZK proof
        address mediator;             // Assigned mediator (if in mediation)
        string ipfsMetadataUri;       // IPFS URI for dispute metadata
    }

    // =========================================================================
    // State Variables
    // =========================================================================

    // ZK verifier contract (generated by Circom/snarkjs)
    IGroth16Verifier public verifier;

    // Dispute storage
    uint256 public disputeCount;
    mapping(uint256 => Dispute) public disputes;

    // Identity hash to verified dispute mapping
    // identityHash => disputeId => isVerified
    mapping(bytes32 => mapping(uint256 => bool)) public verifiedParties;

    // Mediator registry
    mapping(address => bool) public registeredMediators;
    mapping(address => uint256) public mediatorReputation;

    // Configuration
    uint256 public minStake = 0.01 ether;
    uint256 public negotiationPeriod = 7 days;
    uint256 public mediationPeriod = 14 days;
    uint256 public arbitrationPeriod = 30 days;

    // =========================================================================
    // Events
    // =========================================================================

    event DisputeInitiated(
        uint256 indexed disputeId,
        bytes32 indexed initiatorHash,
        bytes32 evidenceHash,
        uint256 stakeAmount
    );

    event CounterpartyJoined(
        uint256 indexed disputeId,
        bytes32 indexed counterpartyHash,
        uint256 stakeAmount
    );

    event IdentityProofSubmitted(
        uint256 indexed disputeId,
        bytes32 indexed identityHash,
        bool isInitiator
    );

    event PhaseEscalated(
        uint256 indexed disputeId,
        DisputePhase fromPhase,
        DisputePhase toPhase
    );

    event DisputeResolved(
        uint256 indexed disputeId,
        Resolution resolution,
        uint256 initiatorPayout,
        uint256 counterpartyPayout
    );

    event MediatorAssigned(
        uint256 indexed disputeId,
        address indexed mediator
    );

    event ViewingKeyCommitted(
        uint256 indexed disputeId,
        bytes32 keyCommitment
    );

    // =========================================================================
    // Constructor
    // =========================================================================

    constructor(address _verifier) Ownable(msg.sender) {
        verifier = IGroth16Verifier(_verifier);
    }

    // =========================================================================
    // Dispute Lifecycle
    // =========================================================================

    /**
     * @notice Initiate a new dispute with ZK identity
     * @param _initiatorHash Poseidon hash of initiator's identity secret
     * @param _counterpartyHash Poseidon hash of counterparty's identity secret
     * @param _evidenceHash Hash of encrypted evidence
     * @param _viewingKeyCommitment Commitment to viewing key
     * @param _ipfsUri IPFS URI for dispute metadata
     */
    function initiateDispute(
        bytes32 _initiatorHash,
        bytes32 _counterpartyHash,
        bytes32 _evidenceHash,
        bytes32 _viewingKeyCommitment,
        string calldata _ipfsUri
    ) external payable nonReentrant whenNotPaused returns (uint256) {
        require(msg.value >= minStake, "Insufficient stake");
        require(_initiatorHash != bytes32(0), "Invalid initiator hash");
        require(_counterpartyHash != bytes32(0), "Invalid counterparty hash");
        require(_initiatorHash != _counterpartyHash, "Same party hashes");

        uint256 disputeId = disputeCount++;

        disputes[disputeId] = Dispute({
            id: disputeId,
            initiatorHash: _initiatorHash,
            counterpartyHash: _counterpartyHash,
            viewingKeyCommitment: _viewingKeyCommitment,
            evidenceHash: _evidenceHash,
            stakeAmount: msg.value,
            counterpartyStake: 0,
            createdAt: block.timestamp,
            lastActionAt: block.timestamp,
            deadline: block.timestamp + negotiationPeriod,
            phase: DisputePhase.Initiated,
            resolution: Resolution.None,
            initiatorVerified: false,
            counterpartyVerified: false,
            mediator: address(0),
            ipfsMetadataUri: _ipfsUri
        });

        emit DisputeInitiated(disputeId, _initiatorHash, _evidenceHash, msg.value);
        emit ViewingKeyCommitted(disputeId, _viewingKeyCommitment);

        return disputeId;
    }

    /**
     * @notice Counterparty joins the dispute by staking
     * @param _disputeId The dispute to join
     * @param _evidenceHash Additional evidence hash from counterparty
     */
    function joinDispute(
        uint256 _disputeId,
        bytes32 _evidenceHash
    ) external payable nonReentrant whenNotPaused {
        Dispute storage d = disputes[_disputeId];
        require(d.phase == DisputePhase.Initiated, "Invalid phase");
        require(d.counterpartyStake == 0, "Already joined");
        require(msg.value >= minStake, "Insufficient stake");

        d.counterpartyStake = msg.value;
        d.phase = DisputePhase.Negotiation;
        d.lastActionAt = block.timestamp;
        d.deadline = block.timestamp + negotiationPeriod;

        // Combine evidence hashes if counterparty provides additional evidence
        if (_evidenceHash != bytes32(0)) {
            d.evidenceHash = keccak256(abi.encodePacked(d.evidenceHash, _evidenceHash));
        }

        emit CounterpartyJoined(_disputeId, d.counterpartyHash, msg.value);
        emit PhaseEscalated(_disputeId, DisputePhase.Initiated, DisputePhase.Negotiation);
    }

    /**
     * @notice Submit ZK proof of identity
     * @dev Verifies caller knows the identity secret that hashes to initiatorHash or counterpartyHash
     * @param _disputeId The dispute ID
     * @param _proofA Groth16 proof component A
     * @param _proofB Groth16 proof component B
     * @param _proofC Groth16 proof component C
     * @param _publicSignals Public signals [identityManager]
     */
    function submitIdentityProof(
        uint256 _disputeId,
        uint[2] calldata _proofA,
        uint[2][2] calldata _proofB,
        uint[2] calldata _proofC,
        uint[1] calldata _publicSignals
    ) external whenNotPaused {
        Dispute storage d = disputes[_disputeId];
        require(d.phase != DisputePhase.Resolved && d.phase != DisputePhase.Dismissed, "Dispute closed");

        // Verify the ZK proof
        require(verifier.verifyProof(_proofA, _proofB, _proofC, _publicSignals), "Invalid ZK proof");

        bytes32 provenHash = bytes32(_publicSignals[0]);

        // Check if proof matches initiator or counterparty
        if (provenHash == d.initiatorHash) {
            require(!d.initiatorVerified, "Already verified");
            d.initiatorVerified = true;
            verifiedParties[provenHash][_disputeId] = true;
            emit IdentityProofSubmitted(_disputeId, provenHash, true);
        } else if (provenHash == d.counterpartyHash) {
            require(!d.counterpartyVerified, "Already verified");
            d.counterpartyVerified = true;
            verifiedParties[provenHash][_disputeId] = true;
            emit IdentityProofSubmitted(_disputeId, provenHash, false);
        } else {
            revert("Hash does not match dispute parties");
        }

        d.lastActionAt = block.timestamp;
    }

    /**
     * @notice Escalate dispute to next phase
     * @param _disputeId The dispute ID
     */
    function escalateDispute(uint256 _disputeId) external whenNotPaused {
        Dispute storage d = disputes[_disputeId];
        require(block.timestamp >= d.deadline, "Deadline not reached");
        require(d.resolution == Resolution.None, "Already resolved");

        DisputePhase oldPhase = d.phase;

        if (d.phase == DisputePhase.Initiated) {
            // Counterparty didn't join - dismiss
            d.phase = DisputePhase.Dismissed;
            d.resolution = Resolution.Dismissed;
            _refundInitiator(_disputeId);
        } else if (d.phase == DisputePhase.Negotiation) {
            d.phase = DisputePhase.Mediation;
            d.deadline = block.timestamp + mediationPeriod;
        } else if (d.phase == DisputePhase.Mediation) {
            d.phase = DisputePhase.Arbitration;
            d.deadline = block.timestamp + arbitrationPeriod;
        } else if (d.phase == DisputePhase.Arbitration) {
            // Arbitration timeout - split stakes
            d.phase = DisputePhase.Resolved;
            d.resolution = Resolution.MutualSettlement;
            _splitStakes(_disputeId);
        }

        d.lastActionAt = block.timestamp;
        emit PhaseEscalated(_disputeId, oldPhase, d.phase);
    }

    /**
     * @notice Submit mutual settlement (both parties agree)
     * @dev Requires both parties to have submitted ZK proofs
     * @param _disputeId The dispute ID
     * @param _initiatorShare Percentage to initiator (0-100)
     */
    function submitSettlement(
        uint256 _disputeId,
        uint8 _initiatorShare
    ) external nonReentrant whenNotPaused {
        Dispute storage d = disputes[_disputeId];
        require(d.phase == DisputePhase.Negotiation || d.phase == DisputePhase.Mediation, "Invalid phase");
        require(d.initiatorVerified && d.counterpartyVerified, "Both parties must verify identity");
        require(_initiatorShare <= 100, "Invalid share");

        d.phase = DisputePhase.Resolved;
        d.resolution = Resolution.MutualSettlement;

        uint256 totalStake = d.stakeAmount + d.counterpartyStake;
        uint256 initiatorPayout = (totalStake * _initiatorShare) / 100;
        uint256 counterpartyPayout = totalStake - initiatorPayout;

        // Note: Actual payout would require verified addresses or withdrawal pattern
        // For privacy, we emit events and use off-chain claiming

        emit DisputeResolved(_disputeId, Resolution.MutualSettlement, initiatorPayout, counterpartyPayout);
    }

    // =========================================================================
    // Mediator Functions
    // =========================================================================

    /**
     * @notice Register as a mediator
     */
    function registerMediator() external {
        registeredMediators[msg.sender] = true;
        mediatorReputation[msg.sender] = 100; // Starting reputation
    }

    /**
     * @notice Assign mediator to dispute (owner or auto-assignment)
     */
    function assignMediator(uint256 _disputeId, address _mediator) external onlyOwner {
        Dispute storage d = disputes[_disputeId];
        require(d.phase == DisputePhase.Mediation, "Not in mediation");
        require(registeredMediators[_mediator], "Not registered mediator");
        require(d.mediator == address(0), "Mediator already assigned");

        d.mediator = _mediator;
        emit MediatorAssigned(_disputeId, _mediator);
    }

    /**
     * @notice Mediator submits resolution recommendation
     */
    function submitMediatorResolution(
        uint256 _disputeId,
        Resolution _resolution,
        uint8 _initiatorShare
    ) external nonReentrant {
        Dispute storage d = disputes[_disputeId];
        require(d.phase == DisputePhase.Mediation, "Not in mediation");
        require(msg.sender == d.mediator, "Not assigned mediator");
        require(_resolution != Resolution.None, "Invalid resolution");
        require(_initiatorShare <= 100, "Invalid share");

        d.phase = DisputePhase.Resolved;
        d.resolution = _resolution;

        uint256 totalStake = d.stakeAmount + d.counterpartyStake;
        uint256 initiatorPayout = (totalStake * _initiatorShare) / 100;
        uint256 counterpartyPayout = totalStake - initiatorPayout;

        emit DisputeResolved(_disputeId, _resolution, initiatorPayout, counterpartyPayout);
    }

    // =========================================================================
    // View Functions
    // =========================================================================

    function getDispute(uint256 _disputeId) external view returns (Dispute memory) {
        return disputes[_disputeId];
    }

    function isPartyVerified(bytes32 _identityHash, uint256 _disputeId) external view returns (bool) {
        return verifiedParties[_identityHash][_disputeId];
    }

    // =========================================================================
    // Admin Functions
    // =========================================================================

    function updateVerifier(address _newVerifier) external onlyOwner {
        verifier = IGroth16Verifier(_newVerifier);
    }

    function updateMinStake(uint256 _newMinStake) external onlyOwner {
        minStake = _newMinStake;
    }

    function pause() external onlyOwner {
        _pause();
    }

    function unpause() external onlyOwner {
        _unpause();
    }

    // =========================================================================
    // Internal Functions
    // =========================================================================

    function _refundInitiator(uint256 _disputeId) internal {
        Dispute storage d = disputes[_disputeId];
        uint256 refund = d.stakeAmount;
        d.stakeAmount = 0;

        // Refund via withdrawal pattern would be implemented here
        emit DisputeResolved(_disputeId, Resolution.Dismissed, refund, 0);
    }

    function _splitStakes(uint256 _disputeId) internal {
        Dispute storage d = disputes[_disputeId];
        uint256 totalStake = d.stakeAmount + d.counterpartyStake;
        uint256 halfStake = totalStake / 2;

        emit DisputeResolved(_disputeId, Resolution.MutualSettlement, halfStake, totalStake - halfStake);
    }
}
