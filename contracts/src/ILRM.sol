// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/utils/ReentrancyGuard.sol";
import "@openzeppelin/contracts/utils/Pausable.sol";

/**
 * @title IGroth16Verifier
 * @notice Interface for ZK proof verification (generated by snarkjs)
 */
interface IGroth16Verifier {
    function verifyProof(
        uint[2] calldata _pA,
        uint[2][2] calldata _pB,
        uint[2] calldata _pC,
        uint[1] calldata _pubSignals
    ) external view returns (bool);
}

/**
 * @title ILRM - Incentivized Layered Resolution Module
 * @notice Privacy-preserving dispute resolution with ZK identity proofs
 *
 * Features:
 * - ZK identity proofs for anonymous dispute participation
 * - Viewing key commitments for selective de-anonymization
 * - Multi-phase escalation (negotiation → mediation → arbitration)
 * - Staking-based incentive alignment
 *
 * Privacy Architecture:
 * 1. Parties identified by hashes (initiatorHash, counterpartyHash)
 * 2. ZK proofs verify party identity without revealing addresses
 * 3. Viewing keys enable authorized access to encrypted evidence
 * 4. All sensitive data stored off-chain (IPFS/Arweave)
 */
contract ILRM is Ownable, ReentrancyGuard, Pausable {
    // =========================================================================
    // Types
    // =========================================================================

    enum DisputePhase {
        Initiated,      // Dispute created, awaiting counterparty response
        Negotiation,    // Direct negotiation between parties
        Mediation,      // Third-party mediator involved
        Arbitration,    // Binding arbitration
        Resolved,       // Settlement reached
        Dismissed       // Dispute dismissed (timeout/invalid)
    }

    enum Resolution {
        None,
        InitiatorWins,
        CounterpartyWins,
        MutualSettlement,
        Dismissed
    }

    struct Dispute {
        uint256 id;
        bytes32 initiatorHash;        // Poseidon hash of initiator's identity secret
        bytes32 counterpartyHash;     // Poseidon hash of counterparty's identity secret
        bytes32 viewingKeyCommitment; // Commitment to viewing key for evidence decryption
        bytes32 evidenceHash;         // Hash of encrypted evidence (content on IPFS)
        uint256 stakeAmount;          // Amount staked by initiator
        uint256 counterpartyStake;    // Amount staked by counterparty
        uint256 createdAt;
        uint256 lastActionAt;
        uint256 deadline;             // Current phase deadline
        DisputePhase phase;
        Resolution resolution;
        bool initiatorVerified;       // Has initiator submitted valid ZK proof
        bool counterpartyVerified;    // Has counterparty submitted valid ZK proof
        address mediator;             // Assigned mediator (if in mediation)
        string ipfsMetadataUri;       // IPFS URI for dispute metadata
    }

    // =========================================================================
    // State Variables
    // =========================================================================

    // ZK verifier contract (generated by Circom/snarkjs)
    IGroth16Verifier public verifier;

    // Dispute storage
    uint256 public disputeCount;
    mapping(uint256 => Dispute) public disputes;

    // Identity hash to verified dispute mapping
    // identityHash => disputeId => isVerified
    mapping(bytes32 => mapping(uint256 => bool)) public verifiedParties;

    // Mediator registry
    mapping(address => bool) public registeredMediators;
    mapping(address => uint256) public mediatorReputation;

    // Withdrawal balances: identityHash => claimAddress => withdrawable amount
    // Allows verified parties to claim funds to a specified address
    mapping(bytes32 => mapping(address => uint256)) public withdrawableBalances;

    // Identity hash to verified claim address (set when first withdrawal initiated)
    mapping(bytes32 => address) public claimAddresses;

    // Total pending withdrawals (for accounting)
    uint256 public totalPendingWithdrawals;

    // Configuration
    uint256 public minStake = 0.01 ether;
    uint256 public negotiationPeriod = 7 days;
    uint256 public mediationPeriod = 14 days;
    uint256 public arbitrationPeriod = 30 days;

    // =========================================================================
    // Events
    // =========================================================================

    event DisputeInitiated(
        uint256 indexed disputeId,
        bytes32 indexed initiatorHash,
        bytes32 evidenceHash,
        uint256 stakeAmount
    );

    event CounterpartyJoined(
        uint256 indexed disputeId,
        bytes32 indexed counterpartyHash,
        uint256 stakeAmount
    );

    event IdentityProofSubmitted(
        uint256 indexed disputeId,
        bytes32 indexed identityHash,
        bool isInitiator
    );

    event PhaseEscalated(
        uint256 indexed disputeId,
        DisputePhase fromPhase,
        DisputePhase toPhase
    );

    event DisputeResolved(
        uint256 indexed disputeId,
        Resolution resolution,
        uint256 initiatorPayout,
        uint256 counterpartyPayout
    );

    event MediatorAssigned(
        uint256 indexed disputeId,
        address indexed mediator
    );

    event ViewingKeyCommitted(
        uint256 indexed disputeId,
        bytes32 keyCommitment
    );

    event FundsAllocated(
        uint256 indexed disputeId,
        bytes32 indexed identityHash,
        uint256 amount
    );

    event FundsWithdrawn(
        bytes32 indexed identityHash,
        address indexed recipient,
        uint256 amount
    );

    event ClaimAddressSet(
        bytes32 indexed identityHash,
        address indexed claimAddress
    );

    // =========================================================================
    // Constructor
    // =========================================================================

    constructor(address _verifier) Ownable(msg.sender) {
        verifier = IGroth16Verifier(_verifier);
    }

    // =========================================================================
    // Dispute Lifecycle
    // =========================================================================

    /**
     * @notice Initiate a new dispute with ZK identity
     * @param _initiatorHash Poseidon hash of initiator's identity secret
     * @param _counterpartyHash Poseidon hash of counterparty's identity secret
     * @param _evidenceHash Hash of encrypted evidence
     * @param _viewingKeyCommitment Commitment to viewing key
     * @param _ipfsUri IPFS URI for dispute metadata
     */
    function initiateDispute(
        bytes32 _initiatorHash,
        bytes32 _counterpartyHash,
        bytes32 _evidenceHash,
        bytes32 _viewingKeyCommitment,
        string calldata _ipfsUri
    ) external payable nonReentrant whenNotPaused returns (uint256) {
        require(msg.value >= minStake, "Insufficient stake");
        require(_initiatorHash != bytes32(0), "Invalid initiator hash");
        require(_counterpartyHash != bytes32(0), "Invalid counterparty hash");
        require(_initiatorHash != _counterpartyHash, "Same party hashes");

        uint256 disputeId = disputeCount++;

        disputes[disputeId] = Dispute({
            id: disputeId,
            initiatorHash: _initiatorHash,
            counterpartyHash: _counterpartyHash,
            viewingKeyCommitment: _viewingKeyCommitment,
            evidenceHash: _evidenceHash,
            stakeAmount: msg.value,
            counterpartyStake: 0,
            createdAt: block.timestamp,
            lastActionAt: block.timestamp,
            deadline: block.timestamp + negotiationPeriod,
            phase: DisputePhase.Initiated,
            resolution: Resolution.None,
            initiatorVerified: false,
            counterpartyVerified: false,
            mediator: address(0),
            ipfsMetadataUri: _ipfsUri
        });

        emit DisputeInitiated(disputeId, _initiatorHash, _evidenceHash, msg.value);
        emit ViewingKeyCommitted(disputeId, _viewingKeyCommitment);

        return disputeId;
    }

    /**
     * @notice Counterparty joins the dispute by staking
     * @param _disputeId The dispute to join
     * @param _evidenceHash Additional evidence hash from counterparty
     */
    function joinDispute(
        uint256 _disputeId,
        bytes32 _evidenceHash
    ) external payable nonReentrant whenNotPaused {
        Dispute storage d = disputes[_disputeId];
        require(d.phase == DisputePhase.Initiated, "Invalid phase");
        require(d.counterpartyStake == 0, "Already joined");
        require(msg.value >= minStake, "Insufficient stake");

        d.counterpartyStake = msg.value;
        d.phase = DisputePhase.Negotiation;
        d.lastActionAt = block.timestamp;
        d.deadline = block.timestamp + negotiationPeriod;

        // Combine evidence hashes if counterparty provides additional evidence
        if (_evidenceHash != bytes32(0)) {
            d.evidenceHash = keccak256(abi.encodePacked(d.evidenceHash, _evidenceHash));
        }

        emit CounterpartyJoined(_disputeId, d.counterpartyHash, msg.value);
        emit PhaseEscalated(_disputeId, DisputePhase.Initiated, DisputePhase.Negotiation);
    }

    /**
     * @notice Submit ZK proof of identity
     * @dev Verifies caller knows the identity secret that hashes to initiatorHash or counterpartyHash
     * @param _disputeId The dispute ID
     * @param _proofA Groth16 proof component A
     * @param _proofB Groth16 proof component B
     * @param _proofC Groth16 proof component C
     * @param _publicSignals Public signals [identityHash]
     */
    function submitIdentityProof(
        uint256 _disputeId,
        uint[2] calldata _proofA,
        uint[2][2] calldata _proofB,
        uint[2] calldata _proofC,
        uint[1] calldata _publicSignals
    ) external whenNotPaused {
        Dispute storage d = disputes[_disputeId];

        // --- PUBLIC INPUT VALIDATION FIRST (cheap checks before expensive ZK verification) ---

        // 1. Validate dispute state
        require(d.phase != DisputePhase.Resolved && d.phase != DisputePhase.Dismissed, "Dispute closed");
        require(d.id == _disputeId, "Invalid dispute ID"); // Ensure dispute exists

        // 2. Extract and validate the identity hash from public signals
        bytes32 claimedHash = bytes32(_publicSignals[0]);
        require(claimedHash != bytes32(0), "Invalid identity hash");

        // 3. Check that the claimed identity hash matches one of the dispute parties
        //    This prevents wasting gas on proofs for unrelated identities
        bool isInitiator = (claimedHash == d.initiatorHash);
        bool isCounterparty = (claimedHash == d.counterpartyHash);
        require(isInitiator || isCounterparty, "Identity not party to dispute");

        // 4. Check party hasn't already verified
        if (isInitiator) {
            require(!d.initiatorVerified, "Initiator already verified");
        } else {
            require(!d.counterpartyVerified, "Counterparty already verified");
        }

        // --- NOW PERFORM EXPENSIVE ZK VERIFICATION ---
        // Only called after all cheap validations pass
        require(verifier.verifyProof(_proofA, _proofB, _proofC, _publicSignals), "Invalid ZK proof");

        // --- UPDATE STATE ---
        if (isInitiator) {
            d.initiatorVerified = true;
            verifiedParties[claimedHash][_disputeId] = true;
            emit IdentityProofSubmitted(_disputeId, claimedHash, true);
        } else {
            d.counterpartyVerified = true;
            verifiedParties[claimedHash][_disputeId] = true;
            emit IdentityProofSubmitted(_disputeId, claimedHash, false);
        }

        d.lastActionAt = block.timestamp;
    }

    /**
     * @notice Escalate dispute to next phase
     * @param _disputeId The dispute ID
     */
    function escalateDispute(uint256 _disputeId) external whenNotPaused {
        Dispute storage d = disputes[_disputeId];
        require(block.timestamp >= d.deadline, "Deadline not reached");
        require(d.resolution == Resolution.None, "Already resolved");

        DisputePhase oldPhase = d.phase;

        if (d.phase == DisputePhase.Initiated) {
            // Counterparty didn't join - dismiss
            d.phase = DisputePhase.Dismissed;
            d.resolution = Resolution.Dismissed;
            _refundInitiator(_disputeId);
        } else if (d.phase == DisputePhase.Negotiation) {
            d.phase = DisputePhase.Mediation;
            d.deadline = block.timestamp + mediationPeriod;
        } else if (d.phase == DisputePhase.Mediation) {
            d.phase = DisputePhase.Arbitration;
            d.deadline = block.timestamp + arbitrationPeriod;
        } else if (d.phase == DisputePhase.Arbitration) {
            // Arbitration timeout - split stakes
            d.phase = DisputePhase.Resolved;
            d.resolution = Resolution.MutualSettlement;
            _splitStakes(_disputeId);
        }

        d.lastActionAt = block.timestamp;
        emit PhaseEscalated(_disputeId, oldPhase, d.phase);
    }

    /**
     * @notice Submit mutual settlement (both parties agree)
     * @dev Requires both parties to have submitted ZK proofs
     * @param _disputeId The dispute ID
     * @param _initiatorShare Percentage to initiator (0-100)
     */
    function submitSettlement(
        uint256 _disputeId,
        uint8 _initiatorShare
    ) external nonReentrant whenNotPaused {
        Dispute storage d = disputes[_disputeId];
        require(d.phase == DisputePhase.Negotiation || d.phase == DisputePhase.Mediation, "Invalid phase");
        require(d.initiatorVerified && d.counterpartyVerified, "Both parties must verify identity");
        require(_initiatorShare <= 100, "Invalid share");

        d.phase = DisputePhase.Resolved;
        d.resolution = Resolution.MutualSettlement;

        // Distribute funds using pull pattern
        _distributeSettlement(_disputeId, _initiatorShare);
    }

    // =========================================================================
    // Mediator Functions
    // =========================================================================

    /**
     * @notice Register as a mediator
     */
    function registerMediator() external {
        registeredMediators[msg.sender] = true;
        mediatorReputation[msg.sender] = 100; // Starting reputation
    }

    /**
     * @notice Assign mediator to dispute (owner or auto-assignment)
     */
    function assignMediator(uint256 _disputeId, address _mediator) external onlyOwner {
        Dispute storage d = disputes[_disputeId];
        require(d.phase == DisputePhase.Mediation, "Not in mediation");
        require(registeredMediators[_mediator], "Not registered mediator");
        require(d.mediator == address(0), "Mediator already assigned");

        d.mediator = _mediator;
        emit MediatorAssigned(_disputeId, _mediator);
    }

    /**
     * @notice Mediator submits resolution recommendation
     */
    function submitMediatorResolution(
        uint256 _disputeId,
        Resolution _resolution,
        uint8 _initiatorShare
    ) external nonReentrant {
        Dispute storage d = disputes[_disputeId];
        require(d.phase == DisputePhase.Mediation, "Not in mediation");
        require(msg.sender == d.mediator, "Not assigned mediator");
        require(_resolution != Resolution.None, "Invalid resolution");
        require(_initiatorShare <= 100, "Invalid share");

        d.phase = DisputePhase.Resolved;
        d.resolution = _resolution;

        // Distribute funds using pull pattern
        _distributeSettlement(_disputeId, _initiatorShare);
    }

    // =========================================================================
    // View Functions
    // =========================================================================

    function getDispute(uint256 _disputeId) external view returns (Dispute memory) {
        return disputes[_disputeId];
    }

    function isPartyVerified(bytes32 _identityHash, uint256 _disputeId) external view returns (bool) {
        return verifiedParties[_identityHash][_disputeId];
    }

    // =========================================================================
    // Admin Functions
    // =========================================================================

    function updateVerifier(address _newVerifier) external onlyOwner {
        verifier = IGroth16Verifier(_newVerifier);
    }

    function updateMinStake(uint256 _newMinStake) external onlyOwner {
        minStake = _newMinStake;
    }

    function pause() external onlyOwner {
        _pause();
    }

    function unpause() external onlyOwner {
        _unpause();
    }

    // =========================================================================
    // Internal Functions
    // =========================================================================

    function _refundInitiator(uint256 _disputeId) internal {
        Dispute storage d = disputes[_disputeId];
        uint256 refund = d.stakeAmount;
        d.stakeAmount = 0;

        // Allocate funds to initiator for withdrawal
        _allocateFunds(_disputeId, d.initiatorHash, refund);

        emit DisputeResolved(_disputeId, Resolution.Dismissed, refund, 0);
    }

    function _splitStakes(uint256 _disputeId) internal {
        Dispute storage d = disputes[_disputeId];
        uint256 totalStake = d.stakeAmount + d.counterpartyStake;
        uint256 halfStake = totalStake / 2;

        // Reset stakes to prevent double-spending
        d.stakeAmount = 0;
        d.counterpartyStake = 0;

        // Allocate funds to both parties
        _allocateFunds(_disputeId, d.initiatorHash, halfStake);
        _allocateFunds(_disputeId, d.counterpartyHash, totalStake - halfStake);

        emit DisputeResolved(_disputeId, Resolution.MutualSettlement, halfStake, totalStake - halfStake);
    }

    /**
     * @notice Internal function to allocate funds to an identity hash
     * @param _disputeId The dispute ID
     * @param _identityHash The identity hash to allocate funds to
     * @param _amount Amount to allocate
     */
    function _allocateFunds(
        uint256 _disputeId,
        bytes32 _identityHash,
        uint256 _amount
    ) internal {
        if (_amount == 0) return;

        address claimAddr = claimAddresses[_identityHash];
        if (claimAddr == address(0)) {
            // No claim address set yet - use a placeholder that will be set on claim
            claimAddr = address(this);
        }

        withdrawableBalances[_identityHash][claimAddr] += _amount;
        totalPendingWithdrawals += _amount;

        emit FundsAllocated(_disputeId, _identityHash, _amount);
    }

    /**
     * @notice Distribute settlement funds based on share
     * @param _disputeId The dispute ID
     * @param _initiatorShare Percentage to initiator (0-100)
     */
    function _distributeSettlement(
        uint256 _disputeId,
        uint8 _initiatorShare
    ) internal {
        Dispute storage d = disputes[_disputeId];
        uint256 totalStake = d.stakeAmount + d.counterpartyStake;
        uint256 initiatorPayout = (totalStake * _initiatorShare) / 100;
        uint256 counterpartyPayout = totalStake - initiatorPayout;

        // Reset stakes to prevent double-spending
        d.stakeAmount = 0;
        d.counterpartyStake = 0;

        // Allocate funds
        _allocateFunds(_disputeId, d.initiatorHash, initiatorPayout);
        _allocateFunds(_disputeId, d.counterpartyHash, counterpartyPayout);

        emit DisputeResolved(_disputeId, d.resolution, initiatorPayout, counterpartyPayout);
    }

    // =========================================================================
    // Withdrawal Functions
    // =========================================================================

    /**
     * @notice Set claim address for an identity hash (requires ZK proof verification)
     * @dev Must have verified identity in at least one dispute
     * @param _identityHash The identity hash
     * @param _claimAddress The address to receive withdrawals
     * @param _disputeId A dispute where this identity is verified
     * @param _proofA Groth16 proof component A
     * @param _proofB Groth16 proof component B
     * @param _proofC Groth16 proof component C
     * @param _publicSignals Public signals containing identity hash
     */
    function setClaimAddress(
        bytes32 _identityHash,
        address _claimAddress,
        uint256 _disputeId,
        uint[2] calldata _proofA,
        uint[2][2] calldata _proofB,
        uint[2] calldata _proofC,
        uint[1] calldata _publicSignals
    ) external nonReentrant whenNotPaused {
        require(_claimAddress != address(0), "Invalid claim address");
        require(claimAddresses[_identityHash] == address(0), "Claim address already set");

        // Verify ZK proof matches the identity hash
        require(verifier.verifyProof(_proofA, _proofB, _proofC, _publicSignals), "Invalid ZK proof");
        require(bytes32(_publicSignals[0]) == _identityHash, "Proof does not match identity");

        // Verify this identity is verified in the specified dispute
        require(verifiedParties[_identityHash][_disputeId], "Identity not verified in dispute");

        // Set claim address
        claimAddresses[_identityHash] = _claimAddress;

        // Transfer any funds held at contract address to new claim address
        uint256 pendingAmount = withdrawableBalances[_identityHash][address(this)];
        if (pendingAmount > 0) {
            withdrawableBalances[_identityHash][address(this)] = 0;
            withdrawableBalances[_identityHash][_claimAddress] = pendingAmount;
        }

        emit ClaimAddressSet(_identityHash, _claimAddress);
    }

    /**
     * @notice Withdraw funds allocated to an identity hash
     * @param _identityHash The identity hash
     */
    function withdraw(bytes32 _identityHash) external nonReentrant whenNotPaused {
        address claimAddr = claimAddresses[_identityHash];
        require(claimAddr != address(0), "Claim address not set");
        require(claimAddr == msg.sender, "Not authorized");

        uint256 amount = withdrawableBalances[_identityHash][msg.sender];
        require(amount > 0, "No funds to withdraw");

        // Update state before transfer (CEI pattern)
        withdrawableBalances[_identityHash][msg.sender] = 0;
        totalPendingWithdrawals -= amount;

        // Transfer funds
        (bool success, ) = msg.sender.call{value: amount}("");
        require(success, "Transfer failed");

        emit FundsWithdrawn(_identityHash, msg.sender, amount);
    }

    /**
     * @notice Get withdrawable balance for an identity hash
     * @param _identityHash The identity hash
     * @return amount The withdrawable amount
     */
    function getWithdrawableBalance(bytes32 _identityHash) external view returns (uint256) {
        address claimAddr = claimAddresses[_identityHash];
        if (claimAddr == address(0)) {
            // Check if there are funds waiting for claim address to be set
            return withdrawableBalances[_identityHash][address(this)];
        }
        return withdrawableBalances[_identityHash][claimAddr];
    }

    /**
     * @notice Emergency withdrawal by owner (only for stuck funds after long timeout)
     * @dev Can only withdraw funds that have been unclaimed for over 365 days
     * @param _disputeId The dispute with unclaimed funds
     */
    function emergencyWithdraw(uint256 _disputeId) external onlyOwner nonReentrant {
        Dispute storage d = disputes[_disputeId];
        require(d.phase == DisputePhase.Resolved || d.phase == DisputePhase.Dismissed, "Dispute not closed");
        require(block.timestamp > d.lastActionAt + 365 days, "Funds not yet claimable by owner");

        // Only allow withdrawal of actually stuck funds
        uint256 initiatorBalance = withdrawableBalances[d.initiatorHash][address(this)];
        uint256 counterpartyBalance = withdrawableBalances[d.counterpartyHash][address(this)];

        if (initiatorBalance > 0) {
            withdrawableBalances[d.initiatorHash][address(this)] = 0;
            totalPendingWithdrawals -= initiatorBalance;
        }
        if (counterpartyBalance > 0) {
            withdrawableBalances[d.counterpartyHash][address(this)] = 0;
            totalPendingWithdrawals -= counterpartyBalance;
        }

        uint256 total = initiatorBalance + counterpartyBalance;
        require(total > 0, "No stuck funds");

        (bool success, ) = owner().call{value: total}("");
        require(success, "Transfer failed");
    }
}
